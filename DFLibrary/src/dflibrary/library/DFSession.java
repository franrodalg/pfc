package dflibrary.library;

import dflibrary.library.param.AID;
import dflibrary.library.security.AuthType;
import dflibrary.utils.ba.BAUtils;

/**
 * Manages the control and update of the different parameters
 * needed during a communication session with a Mifare DESfire card
 * @author Francisco Rodriguez Algarra
 *
 */
public class DFSession {

	/**
	 * Sets the session parameters to their default values
	 */
	public DFSession(){
		
		this.authType = AuthType.NO_AUTH;
		this.selectedAID = new AID(0);
		this.sessionKey = null;
		this.PICCAuth = false;
		this.cmacIV = null;
		this.cmacOK = false;
		
	}
	
	/**
	 * Re-starts the authentication status if needed
	 */
	public void resetAuth(){
		
		if(this.authType != AuthType.TDEA_NATIVE){
		
			cancelAuth();
			
		}
		
	}
	
	/**
	 * Forces the re-start of the authentication status
	 */
	public void cancelAuth(){
				
		this.authType = AuthType.NO_AUTH;
		this.authKeyNum = 0;
		this.sessionKey = null;		
		this.PICCAuth = false;
		this.cmacIV = null;
		this.cmacOK = false;
		
	}
		
	/**
	 * Stores the parameters of the new authentication status
	 * @param newAuthType an instance of class <code>AuthType</code>
	 * representing the type of authentication
	 * @param authKeyNum an int representing the number of the key
	 * to which the authentication has been achieved
	 * @param newSessionKey a byte array containing the session key
	 * generated by means of the authentication procedure
	 * @param PICCAuth a boolean indicating whether the card can
	 * be trusted or not
	 */
	public void setAuth(AuthType newAuthType, int authKeyNum, 
			byte[] newSessionKey, boolean PICCAuth){
		
		if((newAuthType == null) || (newSessionKey == null)) 
			throw new NullPointerException();
		if((authKeyNum < 0) || (authKeyNum > 14)) 
			throw new IllegalArgumentException();
		
		this.authType = newAuthType;
		this.authKeyNum = authKeyNum;
		this.sessionKey = newSessionKey;
		this.PICCAuth = PICCAuth;
		
		if((newAuthType == AuthType.NO_AUTH) || 
				(newAuthType == AuthType.TDEA_NATIVE)) 
			this.cmacIV = null;
		else if(newAuthType == AuthType.AES) 
			this.cmacIV = new byte[16];
		else this.cmacIV = new byte[8];
	}
	
	/**
	 * Updates the identifier of the currently selected application
	 * within the card
	 * @param aid an instance of class <code>AID</code> representing
	 * the currently selected application
	 */
	public void setSelectedAID(AID aid){
		
		if(aid == null) throw new NullPointerException();
		
		this.selectedAID = aid;
		resetAuth();
		
	}
	
	/**
	 * @return an instance of class <code>AuthType</code> representing
	 * the current authentication type
	 */
	public AuthType getAuthType(){ return this.authType; }

	/**
	 * @return an int representing the number of the key
	 * to which the authentication has been achieved
	 */
	public int getAuthKeyNum(){ return this.authKeyNum; }
	
	/**
	 * @return a byte array containing the session key
	 * generated by means of the authentication procedure
	 */
	public byte[] getSessionKey(){ return this.sessionKey; }
	
	/**
	 * @return a boolean indicating whether the card can
	 * be trusted or not
	 */
	public boolean getPICCAuth(){ return this.PICCAuth; }
		
	/**
	 * @return an instance of class <code>AID</code> representing
	 * the currently selected application
	 */
	public AID getSelectedAID(){ return this.selectedAID; }
	
	//CMAC
	
	/**
	 * Updates the new initial vector for the computation of the CMAC
	 * @param newIV a byte array containing the new CMAC initial vector
	 */
	public void updateCmacIV(byte[] newIV){
		
		if(newIV == null) throw new NullPointerException();
		
		this.cmacIV = newIV;
		
	}
	
	/**
	 * Updates the new initial vector for the computation of the CMAC
	 * and indicates whether the previous CMAC check has been successful
	 * or not
	 * @param newIV a byte array containing the new CMAC initial vector
	 * @param cmacOK a boolean indicating whether the previous CMAC check
	 * has been successful or not
	 */
	public void updateCmacIV(byte[] newIV, boolean cmacOK){
		
		if(newIV == null) throw new NullPointerException();
		
		this.cmacIV = newIV;
		this.cmacOK = cmacOK;
		
	}
	
	/**
	 * Retrieves the current CMAC initial value
	 * @return a byte array containing the current CMAC initial value
	 */
	public byte[] getCmacIV(){ return this.cmacIV; }
	
	/**
	 * Retrieves the current CMAC check status
	 * @return <code>true</code> if the previous CMAC check was successful;
	 * <code>false</code> otherwise
	 */
	public boolean getCmacOK(){ return this.cmacOK; }
	
	public String toString(){
		
		String s = "";
		
		s = s + "Current selected application: " + this.selectedAID.toString() + "\n";
		s = s + "Current Authentication type: " + this.authType.toString() + "\n";
		
		if(this.authType != AuthType.NO_AUTH){
			
			s = s + "Authentication key number: " + this.authKeyNum + "\n";
			s = s + "Session Key: "+ BAUtils.toString(this.sessionKey) + "\n";
			if(this.PICCAuth) s = s + "PICC successfully auhtenticated\n";
			else s = s + "CAUTION: PICC not successfully authenticated\n";
		
			if(authType != AuthType.TDEA_NATIVE){
				
				s = s + "Current CMAC IV: " + BAUtils.toString(this.cmacIV) + "\n";
				s = s + "Last CMAC check: " + this.cmacOK + "\n";
			}
			
		}
		
		return s;
		
	}
	
	private AuthType authType;	
	private AID selectedAID;
	private int authKeyNum;
	private byte[] sessionKey;
	private boolean PICCAuth;
	private byte[] cmacIV;
	private boolean cmacOK;
}



